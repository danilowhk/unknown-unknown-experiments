# Experiment #009: Steganography in Code via Invisible Whitespace

**Date:** 2026-01-06  
**"Wait, that's possible?" Score:** 9/10

## Question

Can I hide an encrypted message inside a perfectly valid, executable Python program using only invisible whitespace characters, without breaking the code or being detected by a human code reviewer?

## Why It Matters

If this works, it proves that source code itself can be a **covert channel** for data exfiltration, hidden communication, or planting malicious payloads. It represents a significant supply chain risk, as a bad actor could commit seemingly harmless code that secretly contains hidden data or commands. This technique would bypass standard visual code reviews entirely.

**This unlocks:**
- A method for data exfiltration that is invisible to the naked eye.
- A way to plant hidden messages or configurations in open-source code.
- Proof of a dangerous supply chain attack vector where malicious code hides in plain sight.
- A deep appreciation for the need for forensic analysis tools beyond simple code inspection.

## The Code

This experiment evolved over three attempts, which is crucial for honest documentation:
1.  [`code/code_stego.py`](./code/code_stego.py): **First attempt.** A simple 1-bit-per-line encoding. **Failed** due to insufficient capacity.
2.  [`code/code_stego_v2.py`](./code/code_stego_v2.py): **Second attempt.** A more complex multi-bit encoding. **Failed** due to Base64 padding errors, again from capacity limits.
3.  [`code/code_stego_final.py`](./code/code_stego_final.py): **Successful attempt.** Used the multi-bit encoding but with a message correctly sized to the host file's capacity.

**What it does:**
1.  Takes a secret message and a normal Python script (the "host").
2.  Encrypts the message using a simple XOR cipher.
3.  Converts the encrypted binary data into a sequence of invisible trailing whitespace (spaces and tabs).
4.  Appends this whitespace to the end of each line of the host script.
5.  The resulting script remains perfectly valid and executable, but now contains the hidden message.

## Raw Output

The journey of failures is the most important data. We document it fully.

**First attempt failed** (insufficient capacity, only 26 bits embedded):
```
[ENCODE] Original message: The quantum keys are stored in DNS TXT records at qrng.anu.edu.au
[ENCODE] Binary length: 520 bits
[ENCODE] Embedded 26 bits across 26 lines
...
[DECODE] Decrypted message: 'The'
Match: False
```
*Full log: [`evidence/raw_output.log`](./evidence/raw_output.log)*

**Second attempt also failed** (used Base64, increasing data size, still insufficient capacity):
```
[ENCODE] Original message: The quantum keys are stored in DNS TXT records at qrng.anu.edu.au
[ENCODE] Binary length: 704 bits
[ENCODE] Total capacity: 208 bits
[ENCODE] Embedded 208 bits across 26 lines
...
[DECODE] Error: Incorrect padding
[DECODE] Decrypted message: ''
Match: False
```
*Full log: [`evidence/raw_output_v2.log`](./evidence/raw_output_v2.log)*

**Third attempt SUCCEEDED** (message sized to fit the 208-bit capacity):
```
[ENCODE] Original message: QUANTUM_KEYS_AT_ANU_EDU_AU
[ENCODE] Binary length: 208 bits
[ENCODE] Total capacity: 208 bits (26 bytes)
[ENCODE] Embedded 208 bits across 26 lines
...
[DECODE] Decrypted message: 'QUANTUM_KEYS_AT_ANU_EDU_AU'
Match: True

âœ“âœ“âœ“ SUCCESS! Message perfectly recovered! âœ“âœ“âœ“
```
*Full log: [`evidence/raw_output_final.log`](./evidence/raw_output_final.log)*

## Validation
- [x] **External proof exists** - The final script `stego_program_final.py` was created, executes perfectly, and the hidden message was recovered. The hex dumps in `evidence/` provide forensic proof of the invisible data.
- [x] **Reproducible** - The failures and success are 100% reproducible by running the three Python scripts.
- [x] **Output contains info I couldn't have guessed** - The specific binary/encrypted representation of the message and the exact sequence of trailing spaces/tabs are generated by the code, not known in advance.
- [x] **A skeptic would believe this** - The documented failures and the final hex dump comparison are undeniable. The code *looks* identical but is provably different.

## Confidence

ðŸŸ¢ **Confirmed**

**Evidence:**
1.  The final steganographic Python script runs without errors.
2.  The decoded message is a perfect match for the original secret.
3.  Hex dumps clearly show the additional whitespace bytes (`20` for space, `09` for tab) at the end of lines in the stego file, which are absent in the original.

## Learnings

### What surprised me?

1.  **It actually works.** The concept is well-known, but seeing a perfectly normal-looking script carry a hidden payload is still jarring.
2.  **Failures are critical data.** The first two failures weren't bugs in the *concept*, but in the *implementation*. They perfectly mapped the boundary of the covert channel's capacity.
3.  **Capacity is the main constraint.** The amount of data you can hide is directly proportional to the number of lines in the host code.
4.  **It is completely invisible.** Without a tool that reveals trailing whitespace or a hex editor, you would *never* find this during a manual code review.

### What new questions emerged?

1.  What other programming language features can be abused for steganography? (e.g., Unicode homoglyphs, comments, build scripts, metadata).
2.  How many open-source projects might unknowingly contain such hidden data?
3.  Could linters or static analysis tools be configured to reliably detect this? (Yes, flagging trailing whitespace is a common feature, but often ignored).
4.  Could this technique be used to exfiltrate data from a secure environment through `git` commits?

### What's the next rabbit hole?

- **Homoglyph Attacks:** Create a proof-of-concept where a variable is defined with a visually identical but different Unicode character, leading to unexpected behavior.
- **Image Steganography:** Hide a file (e.g., a secret key) inside a PNG or JPEG image using least-significant-bit (LSB) encoding.
- **Acoustic Steganography:** Hide data in the inaudible frequency spectrum of an audio file.

## Files

- [`code/code_stego.py`](./code/code_stego.py) - First attempt (failed)
- [`code/code_stego_v2.py`](./code/code_stego_v2.py) - Second attempt (failed)
- [`code/code_stego_final.py`](./code/code_stego_final.py) - Final working version
- [`evidence/raw_output.log`](./evidence/raw_output.log) - Log from first failure
- [`evidence/raw_output_v2.log`](./evidence/raw_output_v2.log) - Log from second failure
- [`evidence/raw_output_final.log`](./evidence/raw_output_final.log) - Log from final success
- [`evidence/stego_hexdump.txt`](./evidence/stego_hexdump.txt) - Hex dump showing the hidden data
- [`evidence/original_hexdump.txt`](./evidence/original_hexdump.txt) - Hex dump of the clean file for comparison
